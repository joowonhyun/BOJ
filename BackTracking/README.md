# 백트래킹

시간복잡도 : 문제의 유형과 특정 구현에 따라 다름
(N개의 요소로 구성된 조합을 찾는 경우, 시간 복잡도는 O(N!) 또는 O(2^N))

일반적으로 그래프/트리의 모든 원소를 완전 탐색하기 위한 목적으로 사용할 수 있다.

[접근방법]

- 백트래킹의 일반적인 코드 형태는 다음과 같다.

```
function recursive() {
    if 종료 조건을 만족한다면 {
      처리;
    }

    for 자식 노드를 하나씩 확인하며 {
      if 임의의 조건을 만족한다면 {
        자식 노드 방문 처리;
        재귀 함수 호출;
        자식 노드 방문 처리 해제;
      }
    }
}
```

[대표문제] N-Queen 문제

[아이디어]
이 문제는 가능한 모든 조합의 수를 구하는 것과 같다.
매 재귀함수마다 실제로 N x N 모든 위치를 모두 볼 필요가 없다.
(핵심) 맨 처음 행(Row)부터 차례대로 퀸을 놓는다고 생각하면 가짓수를 훨씬 줄일 수 있다.
N-Queen문제는 가능한 조합을 계산하는 것이므로, 현재 행의 이전 행으로 돌아갈 필요가 없다.

- 백트래킹을 기본적으로 가능한 노드에 대해 계속해서 재귀적으로 함수를 호출한다.
- 백트래킹은 모든 경우의 수를 탐색하기에 적합하다.
- N-Queens 문제를 해결하기 위해서는 특정 위치(노드)의 가능 여부를 판단할 필요가 있다.
- 가능한 노드 여부는 다음 두 가지를 보면 된다.

1. 같은 행에 있는지 체크: x1 === x2 / 같은 열에 있는지 체크: y1 === y2
2. 대각선에 있는지 체크: abs(x1,x2) === abs(y1,y2)

[정답코드 예시]

```
let n = 8; // 전체 맵(map)의 크기
let queens = []; // 현재 체스판에 놓은 퀸(queen)의 위치 정보들

function possible(x, y) { // (x, y) 위치에 퀸을 놓을 수 있는지 확인
  for (let [a, b] of queens) { // 현재까지 놓았던 모든 퀸 (Queen)의 위치를 하나씩 확인하며
    if (a == x || b == y) return false; // 행이나 열이 같다면 놓을 수 없음
    if (Math.abs(a - x) == Math.abs(b - y)) return false; // 대각선에 위치한 경우 놓을 수 없음
  }
  return true;
}

let cnt = 0;

function dfs(row) {
  if (row == n) cnt += 1; // 퀸 (Queen)을 N개 배치할 수 있는 경우 카운트
  for (let i = 0; i < n; i++) { //현재 행(row)에 존재하는 열을 하나씩 확인하며
    if (!possible(row, i)) continue; // 현재 위치에 놓을수 없다면 무시
    queens.push([row, i]); //현재 위치에 퀸을 놓기
    dfs(row + 1); // 재귀함수 호출
    queens.pop(); // 현재 위치에서 퀸을 제거하기
  }
}
dfs(0);
console.log(cnt);
```
